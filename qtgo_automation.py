import pandas as pd
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import TimeoutException, NoSuchElementException, WebDriverException
import os

class ChassisAutomation:
    def __init__(self):
        self.driver = None
        self.processed_chassis = []
        self.failed_chassis = []
        self.successful_chassis = []
        
    def setup_driver(self):
        """Configura o driver do Chrome"""
        options = webdriver.ChromeOptions()
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        self.driver = webdriver.Chrome(options=options)
        self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        self.driver.maximize_window()
        
    def load_chassis_list(self):
        """Carrega a lista de chassis do Excel ou input manual"""
        print("=== CARREGAMENTO DE CHASSIS ===")
        print("1. Carregar de arquivo Excel (QTGO_ID.xlsx)")
        print("2. Inserir lista manualmente")
        
        choice = input("\nEscolha uma op√ß√£o (1 ou 2): ").strip()
        
        chassis_list = []
        
        if choice == "1":
            # Arquivo fixo na raiz do projeto
            file_path = "QTGO_ID.xlsx"
            
            try:
                if not os.path.exists(file_path):
                    print(f"‚ùå Arquivo n√£o encontrado: {file_path}")
                    print("üìÅ Certifique-se de que o arquivo QTGO_ID.xlsx est√° na raiz do projeto")
                    return self.load_chassis_list()
                
                print(f"üìä Carregando arquivo: {file_path}")
                df = pd.read_excel(file_path)
                
                print("üìã Colunas dispon√≠veis no Excel:")
                for i, col in enumerate(df.columns):
                    print(f"   {i+1}. {col}")
                
                col_choice = input("\nüî¢ Digite o n√∫mero da coluna que cont√©m os chassis: ").strip()
                try:
                    col_index = int(col_choice) - 1
                    column_name = df.columns[col_index]
                    chassis_list = df[column_name].dropna().astype(str).tolist()
                    print(f"‚úÖ Coluna selecionada: {column_name}")
                except (ValueError, IndexError):
                    print("‚ùå Op√ß√£o inv√°lida!")
                    return self.load_chassis_list()
                    
            except Exception as e:
                print(f"‚ùå Erro ao ler o arquivo Excel: {e}")
                print("üí° Verifique se o arquivo n√£o est√° aberto em outro programa")
                return self.load_chassis_list()
                
        elif choice == "2":
            print("üìù Cole a lista de chassis (um por linha). Digite 'FIM' para finalizar:")
            while True:
                chassis = input("   > ").strip()
                if chassis.upper() == 'FIM':
                    break
                if chassis:
                    chassis_list.append(chassis)
        else:
            print("‚ùå Op√ß√£o inv√°lida!")
            return self.load_chassis_list()
        
        chassis_list = [chassis.strip() for chassis in chassis_list if chassis.strip()]
        print(f"\n‚úÖ {len(chassis_list)} chassis carregados com sucesso!")
        
        # Mostra preview dos primeiros chassis carregados
        if chassis_list:
            print("üìã Preview dos chassis carregados:")
            for i, chassis in enumerate(chassis_list[:5]):
                print(f"   {i+1}. {chassis}")
            if len(chassis_list) > 5:
                print(f"   ... e mais {len(chassis_list) - 5} chassis")
        
        return chassis_list
    
    def wait_for_manual_login(self):
        """Abre o sistema e aguarda login manual"""
        print(f"\n=== ABRINDO SISTEMA ===")
        self.driver.get("https://quantigo.scopemp.net/app/subscriptions")
        
        print("üåê Sistema aberto no navegador.")
        print("üîë Fa√ßa login manualmente e aguarde a p√°gina de subscriptions carregar.")
        input("‚è≥ Pressione ENTER quando estiver na p√°gina de subscriptions e pronto para iniciar a automa√ß√£o...")
        
    def search_chassis(self, chassis):
        """Pesquisa um chassis espec√≠fico"""
        try:
            # Localiza o campo de busca (ID pode variar, ent√£o usa placeholder como backup)
            search_input = None
            try:
                search_input = WebDriverWait(self.driver, 10).until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, "input.mat-input-element[placeholder='Search']"))
                )
            except:
                # Tenta com ID espec√≠fico se n√£o encontrar pelo placeholder
                search_input = self.driver.find_element(By.ID, "mat-input-3")
            
            # Limpa o campo e digita o chassis
            search_input.clear()
            time.sleep(0.5)
            search_input.send_keys(chassis)
            time.sleep(0.5)
            print(f"üîç Chassis '{chassis}' digitado no campo de busca")
            
            # Localiza e clica no bot√£o de pesquisa ESPEC√çFICO
            try:
                # M√©todo 1: Busca o bot√£o que cont√©m especificamente o √≠cone "search"
                search_button = WebDriverWait(self.driver, 5).until(
                    EC.element_to_be_clickable((By.XPATH, "//button[contains(@class, 'mat-icon-button')]//mat-icon[text()='search']/ancestor::button"))
                )
                search_button.click()
                print(f"üîç Bot√£o de busca clicado (m√©todo 1) para chassis: {chassis}")
            except:
                try:
                    # M√©todo 2: Busca dentro da div quantigo-table-actions o bot√£o com √≠cone search
                    search_button = self.driver.find_element(By.CSS_SELECTOR, ".quantigo-table-actions button[mat-icon-button] mat-icon[role='img'][aria-hidden='true']")
                    # Clica no bot√£o pai (o button)
                    search_button = search_button.find_element(By.XPATH, "./ancestor::button")
                    search_button.click()
                    print(f"üîç Bot√£o de busca clicado (m√©todo 2) para chassis: {chassis}")
                except:
                    try:
                        # M√©todo 3: JavaScript click no bot√£o espec√≠fico que cont√©m "search"
                        search_button = self.driver.find_element(By.XPATH, "//div[contains(@class, 'quantigo-table-actions')]//button//mat-icon[contains(text(), 'search')]/parent::*/parent::button")
                        self.driver.execute_script("arguments[0].click();", search_button)
                        print(f"üîç Bot√£o de busca clicado (m√©todo 3 - JavaScript) para chassis: {chassis}")
                    except:
                        # M√©todo 4: Busca o segundo bot√£o mat-icon-button (assumindo que o primeiro √© o menu)
                        search_buttons = self.driver.find_elements(By.CSS_SELECTOR, "button.mat-icon-button")
                        if len(search_buttons) >= 2:
                            # Verifica qual cont√©m o √≠cone search
                            for btn in search_buttons:
                                try:
                                    icon = btn.find_element(By.CSS_SELECTOR, "mat-icon")
                                    if icon.text == "search":
                                        btn.click()
                                        print(f"üîç Bot√£o de busca clicado (m√©todo 4) para chassis: {chassis}")
                                        break
                                except:
                                    continue
                        else:
                            raise Exception("N√£o foi poss√≠vel encontrar o bot√£o de search")
            
            # IMPORTANTE: Aguarda o loading terminar antes de continuar
            print(f"‚è≥ Aguardando sistema carregar resultados para chassis: {chassis}...")
            self.wait_for_loading_to_finish()
            
            print(f"‚úÖ Pesquisa do chassis {chassis} conclu√≠da")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao pesquisar chassis {chassis}: {e}")
            # M√©todo alternativo com ENTER
            try:
                print("üîÑ Tentando m√©todo alternativo com ENTER...")
                if search_input:
                    search_input.send_keys(Keys.ENTER)
                else:
                    search_input = self.driver.find_element(By.CSS_SELECTOR, "input.mat-input-element[placeholder='Search']")
                    search_input.clear()
                    search_input.send_keys(chassis)
                    search_input.send_keys(Keys.ENTER)
                
                # IMPORTANTE: Aguarda o loading terminar mesmo no m√©todo alternativo
                print(f"‚è≥ Aguardando sistema carregar resultados (m√©todo alternativo) para chassis: {chassis}...")
                self.wait_for_loading_to_finish()
                
                print(f"‚úÖ Chassis {chassis} pesquisado (m√©todo alternativo com ENTER)")
                return True
            except Exception as e2:
                print(f"‚ùå Falha tamb√©m no m√©todo alternativo: {e2}")
                return False
    
    def wait_for_loading_to_finish(self, timeout=30):
        """Aguarda o loading spinner desaparecer"""
        try:
            print("üîÑ Verificando se h√° loading ativo...")
            
            # Aguarda um pouco para o loading aparecer se necess√°rio
            time.sleep(1)
            
            # Verifica se existe o spinner de loading
            loading_spinner = self.driver.find_elements(By.CSS_SELECTOR, ".quantigo-progress-spinner")
            
            if loading_spinner:
                print("‚è≥ Loading detectado, aguardando finalizar...")
                # Aguarda o spinner desaparecer
                WebDriverWait(self.driver, timeout).until(
                    EC.invisibility_of_element_located((By.CSS_SELECTOR, ".quantigo-progress-spinner"))
                )
                print("‚úÖ Loading finalizado!")
                
                # Aguarda mais um pouco para garantir que a p√°gina est√° completamente carregada
                time.sleep(2)
            else:
                print("‚úÖ Nenhum loading detectado")
                
            return True
            
        except TimeoutException:
            print(f"‚ö†Ô∏è Timeout aguardando loading finalizar ({timeout}s)")
            return False
        except Exception as e:
            print(f"‚ùå Erro ao aguardar loading: {e}")
            return False
    
    def find_active_records(self):
        """Encontra registros com status Active na tabela"""
        try:
            # Aguarda a tabela carregar completamente
            WebDriverWait(self.driver, 15).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "table.mat-table"))
            )
            
            # Aguarda um pouco mais para garantir que os dados carregaram
            time.sleep(2)
            
            # Procura por todas as linhas da tabela usando o seletor correto
            table_rows = self.driver.find_elements(By.CSS_SELECTOR, "tr.material-table-row.mat-row")
            
            active_rows = []
            
            for row in table_rows:
                # Procura pela c√©lula de status na linha usando o seletor correto
                try:
                    status_cell = row.find_element(By.CSS_SELECTOR, "td.mat-cell-bold.mat-cell.cdk-column-status")
                    status_text = status_cell.text.strip()
                    print(f"üìä Status encontrado: '{status_text}'")
                    
                    if status_text == "Active":
                        active_rows.append(row)
                        print(f"‚úÖ Registro ativo encontrado!")
                        
                        # Debug: mostra informa√ß√µes da linha
                        try:
                            description_cell = row.find_element(By.CSS_SELECTOR, "td.cdk-column-description")
                            print(f"üìù Descri√ß√£o: {description_cell.text[:50]}...")
                        except:
                            pass
                            
                except NoSuchElementException:
                    # Tenta seletor alternativo para status
                    try:
                        status_cell = row.find_element(By.CSS_SELECTOR, "td.cdk-column-status")
                        status_text = status_cell.text.strip()
                        print(f"üìä Status encontrado (alternativo): '{status_text}'")
                        
                        if status_text == "Active":
                            active_rows.append(row)
                            print(f"‚úÖ Registro ativo encontrado (seletor alternativo)!")
                    except NoSuchElementException:
                        print("‚ö†Ô∏è N√£o foi poss√≠vel encontrar c√©lula de status nesta linha")
                        continue
            
            print(f"üìà Total de registros com status Active: {len(active_rows)}")
            return active_rows
            
        except Exception as e:
            print(f"‚ùå Erro ao procurar registros ativos: {e}")
            return []
    
    def wait_for_modal_to_appear(self, timeout=15):
        """Aguarda especificamente o modal de desinstala√ß√£o aparecer"""
        try:
            print("‚è≥ Aguardando modal de desinstala√ß√£o aparecer...")
            
            # Aguarda o campo de location aparecer (indicativo de que o modal carregou)
            WebDriverWait(self.driver, timeout).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "input[formcontrolname='location']"))
            )
            
            # Aguarda um pouco mais para garantir que o modal carregou completamente
            time.sleep(1)
            
            # Verifica se realmente √© vis√≠vel
            location_field = self.driver.find_element(By.CSS_SELECTOR, "input[formcontrolname='location']")
            if location_field.is_displayed():
                print("‚úÖ Modal de desinstala√ß√£o apareceu e est√° vis√≠vel")
                return True
            else:
                print("‚ö†Ô∏è Modal encontrado mas n√£o est√° vis√≠vel")
                return False
                
        except TimeoutException:
            print(f"‚ö†Ô∏è Timeout: Modal n√£o apareceu em {timeout} segundos")
            return False
        except Exception as e:
            print(f"‚ùå Erro aguardando modal aparecer: {e}")
            return False
    
    def click_deinstallation_button(self, row):
        """Clica no bot√£o de desinstala√ß√£o na linha especificada"""
        try:
            # Aguarda qualquer loading finalizar antes de tentar clicar
            self.wait_for_loading_to_finish()
            
            # Procura pela c√©lula de a√ß√µes na linha espec√≠fica
            actions_cell = row.find_element(By.CSS_SELECTOR, "td.mat-cell.cdk-column-actions")
            
            # Dentro da c√©lula de a√ß√µes, procura especificamente pelo bot√£o Deinstallation
            deinstall_buttons = actions_cell.find_elements(By.CSS_SELECTOR, "button.quantigo-table-row-action")
            
            deinstall_button = None
            for button in deinstall_buttons:
                button_text = button.text.strip()
                print(f"üîç Bot√£o encontrado: '{button_text}'")
                if "Deinstallation" in button_text:
                    deinstall_button = button
                    break
            
            if not deinstall_button:
                print("‚ùå Bot√£o Deinstallation n√£o encontrado")
                return False
            
            # Scroll at√© o bot√£o para garantir que est√° vis√≠vel
            self.driver.execute_script("arguments[0].scrollIntoView(true);", deinstall_button)
            time.sleep(1)
            
            # Aguarda o bot√£o estar clic√°vel
            WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable(deinstall_button)
            )
            
            # Verifica novamente se n√£o h√° loading
            if not self.driver.find_elements(By.CSS_SELECTOR, ".quantigo-progress-spinner"):
                # Clica no bot√£o
                deinstall_button.click()
                print("‚úÖ Bot√£o de desinstala√ß√£o clicado")
            else:
                print("‚è≥ Loading ainda ativo, aguardando...")
                self.wait_for_loading_to_finish()
                deinstall_button.click()
                print("‚úÖ Bot√£o de desinstala√ß√£o clicado ap√≥s aguardar loading")
            
            # IMPORTANTE: Aguarda o modal realmente aparecer antes de retornar True
            if self.wait_for_modal_to_appear():
                return True
            else:
                print("‚ùå Modal n√£o apareceu ap√≥s clicar no bot√£o")
                return False
            
        except Exception as e:
            print(f"‚ùå Erro ao clicar no bot√£o de desinstala√ß√£o: {e}")
            # Tenta uma abordagem alternativa com JavaScript
            try:
                self.wait_for_loading_to_finish()
                # Procura por qualquer bot√£o que contenha "Deinstallation"
                deinstall_button = row.find_element(By.XPATH, ".//button[contains(., 'Deinstallation')]")
                self.driver.execute_script("arguments[0].click();", deinstall_button)
                print("‚úÖ Bot√£o de desinstala√ß√£o clicado (m√©todo JavaScript)")
                
                # Aguarda o modal aparecer tamb√©m no m√©todo alternativo
                if self.wait_for_modal_to_appear():
                    return True
                else:
                    print("‚ùå Modal n√£o apareceu ap√≥s clicar (m√©todo alternativo)")
                    return False
                    
            except Exception as e2:
                print(f"‚ùå Falha tamb√©m no m√©todo alternativo: {e2}")
                return False
    
    def fill_modal_and_confirm(self):
        """Preenche o modal de desinstala√ß√£o e confirma"""
        try:
            print("‚è≥ Aguardando modal aparecer...")
            
            # Aguarda o modal aparecer e localiza o campo de location
            location_input = WebDriverWait(self.driver, 15).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "input[formcontrolname='location']"))
            )
            
            print("üìù Campo location encontrado, preenchendo...")
            
            # Preenche com "REMO√á√ÉO"
            location_input.clear()
            time.sleep(0.5)
            location_input.send_keys("REMO√á√ÉO")
            
            print("üîç Campo preenchido, procurando bot√£o OK...")
            
            # M√∫ltiplas tentativas para encontrar e clicar no bot√£o OK
            ok_button = None
            selectors = [
                # Seletor baseado no HTML fornecido
                "button.mat-stroked-button.mat-button-base.mat-primary",
                # Seletor alternativo por texto
                "//button[contains(@class, 'mat-stroked-button') and contains(span, 'Ok')]",
                # Seletor mais espec√≠fico
                "button[color='primary'][mat-stroked-button]",
                # Seletor gen√©rico por texto
                "//button[contains(text(), 'Ok')]",
                # Seletor alternativo
                "button.mat-stroked-button span:contains('Ok')",
                # Seletor XPath mais robusto
                "//button[contains(@class, 'mat-stroked-button') and .//span[text()='Ok']]"
            ]
            
            for i, selector in enumerate(selectors):
                try:
                    print(f"üîÑ Tentativa {i+1}: usando seletor '{selector}'")
                    
                    if selector.startswith("//"):
                        # XPath selector
                        ok_button = WebDriverWait(self.driver, 5).until(
                            EC.element_to_be_clickable((By.XPATH, selector))
                        )
                    else:
                        # CSS selector
                        ok_button = WebDriverWait(self.driver, 5).until(
                            EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
                        )
                    
                    print(f"‚úÖ Bot√£o OK encontrado com seletor {i+1}")
                    break
                    
                except TimeoutException:
                    print(f"‚ö†Ô∏è Seletor {i+1} n√£o funcionou, tentando pr√≥ximo...")
                    continue
                except Exception as e:
                    print(f"‚ùå Erro com seletor {i+1}: {e}")
                    continue
            
            if not ok_button:
                print("üîç Tentando encontrar todos os bot√µes do modal...")
                # √öltima tentativa: encontrar todos os bot√µes e procurar pelo texto
                all_buttons = self.driver.find_elements(By.CSS_SELECTOR, "button")
                for button in all_buttons:
                    try:
                        if "Ok" in button.text or "OK" in button.text:
                            ok_button = button
                            print(f"‚úÖ Bot√£o OK encontrado por busca em todos os bot√µes: '{button.text}'")
                            break
                    except:
                        continue
            
            if not ok_button:
                raise Exception("N√£o foi poss√≠vel encontrar o bot√£o OK em nenhuma tentativa")
            
            # Scroll at√© o bot√£o para garantir visibilidade
            self.driver.execute_script("arguments[0].scrollIntoView(true);", ok_button)
            time.sleep(1)
            
            # Aguarda o bot√£o estar realmente clic√°vel
            WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable(ok_button)
            )
            
            print("üîò Clicando no bot√£o OK...")
            
            # Tenta clicar normalmente primeiro
            try:
                ok_button.click()
                print("‚úÖ Bot√£o OK clicado (m√©todo normal)")
            except Exception as e:
                print(f"‚ùå Erro no clique normal: {e}, tentando JavaScript...")
                # Se falhar, usa JavaScript
                self.driver.execute_script("arguments[0].click();", ok_button)
                print("‚úÖ Bot√£o OK clicado (m√©todo JavaScript)")
            
            print("‚è≥ Modal confirmado, aguardando processamento...")
            
            # Aguarda o modal desaparecer
            try:
                WebDriverWait(self.driver, 10).until(
                    EC.invisibility_of_element_located((By.CSS_SELECTOR, "input[formcontrolname='location']"))
                )
                print("‚úÖ Modal fechado")
            except TimeoutException:
                print("‚ö†Ô∏è Timeout aguardando modal fechar, continuando...")
            
            # Aguarda qualquer loading que possa aparecer
            time.sleep(2)
            self.wait_for_loading_to_finish()
            
            print("‚úÖ Processamento do modal conclu√≠do com sucesso")
            return True
            
        except TimeoutException as e:
            print(f"‚ö†Ô∏è Timeout no modal: {e}")
            # Tenta screenshot para debug
            try:
                self.driver.save_screenshot("modal_error.png")
                print("üì∏ Screenshot salvo como modal_error.png")
            except:
                pass
            return False
            
        except Exception as e:
            print(f"‚ùå Erro ao preencher modal: {e}")
            # Tenta screenshot para debug
            try:
                self.driver.save_screenshot("modal_error.png")
                print("üì∏ Screenshot salvo como modal_error.png")
            except:
                pass
            return False
    
    def process_chassis(self, chassis):
        """Processa um chassi completo"""
        print(f"\n--- üöó Processando chassis: {chassis} ---")
        
        try:
            # 1. Pesquisa o chassis
            if not self.search_chassis(chassis):
                self.failed_chassis.append(f"{chassis} - Erro na pesquisa")
                return False
            
            # 2. Encontra registros ativos
            active_rows = self.find_active_records()
            
            if not active_rows:
                print(f"‚ö†Ô∏è Nenhum registro ativo encontrado para {chassis}")
                self.failed_chassis.append(f"{chassis} - Nenhum registro ativo")
                return False
            
            # 3. Processa cada registro ativo
            processed_count = 0
            for i, row in enumerate(active_rows):
                print(f"üîÑ Processando registro ativo {i+1}/{len(active_rows)}")
                
                if self.click_deinstallation_button(row):
                    if self.fill_modal_and_confirm():
                        processed_count += 1
                        print(f"‚úÖ Registro {i+1} processado com sucesso")
                    else:
                        print(f"‚ùå Falha ao confirmar desinstala√ß√£o do registro {i+1}")
                else:
                    print(f"‚ùå Falha ao clicar em desinstala√ß√£o do registro {i+1}")
                
                # Pequena pausa entre registros
                time.sleep(1)
            
            if processed_count > 0:
                self.successful_chassis.append(f"{chassis} - {processed_count} registro(s) processado(s)")
                print(f"üéâ Chassis {chassis} processado com sucesso! ({processed_count} registros)")
                return True
            else:
                self.failed_chassis.append(f"{chassis} - Falha no processamento")
                return False
                
        except Exception as e:
            print(f"‚ùå Erro geral ao processar chassis {chassis}: {e}")
            self.failed_chassis.append(f"{chassis} - Erro: {str(e)}")
            return False
    
    def check_if_logged_out(self):
        """Verifica se o usu√°rio foi deslogado - chamado apenas quando h√° erro"""
        try:
            # Verifica se foi redirecionado para p√°gina de login
            current_url = self.driver.current_url
            if "login" in current_url.lower() or "auth" in current_url.lower():
                return True
            
            # Verifica se ainda est√° na p√°gina de subscriptions
            if "quantigo.scopemp.net/app/subscriptions" not in current_url:
                return True
            
            # Procura por elementos de login que s√≥ aparecem quando deslogado
            login_indicators = [
                "input[type='password']",
                ".login-form",
                ".auth-container",
                ".login-container"
            ]
            
            for indicator in login_indicators:
                if self.driver.find_elements(By.CSS_SELECTOR, indicator):
                    return True
            
            return False
            
        except:
            return True  # Em caso de erro, assume que foi deslogado
    
    def run_automation(self):
        """Executa a automa√ß√£o completa"""
        try:
            # 1. Configurar driver
            self.setup_driver()
            
            # 2. Carregar lista de chassis
            chassis_list = self.load_chassis_list()
            if not chassis_list:
                print("‚ö†Ô∏è Nenhum chassis para processar!")
                return
            
            # 3. Abrir sistema e aguardar login
            self.wait_for_manual_login()
            
            # 4. Processar cada chassis
            print(f"\n=== üöÄ INICIANDO PROCESSAMENTO DE {len(chassis_list)} CHASSIS ===")
            
            for i, chassis in enumerate(chassis_list, 1):
                print(f"\nüìä Progresso: {i}/{len(chassis_list)}")
                
                # Tenta processar o chassis
                try:
                    self.process_chassis(chassis)
                except Exception as e:
                    # Se houver erro relacionado a logout, verifica
                    if "login" in str(e).lower() or "auth" in str(e).lower():
                        if self.check_if_logged_out():
                            print("üö® ATEN√á√ÉO: Usu√°rio deslogado! Parando a automa√ß√£o.")
                            break
                    print(f"‚ùå Erro ao processar chassis {chassis}: {e}")
                    self.failed_chassis.append(f"{chassis} - Erro: {str(e)}")
                
                # Pausa entre chassis
                time.sleep(2)
            
            # 5. Mostrar resumo
            self.show_summary()
            
        except KeyboardInterrupt:
            print("\n‚ö†Ô∏è Automa√ß√£o interrompida pelo usu√°rio!")
        except Exception as e:
            print(f"‚ùå Erro geral na automa√ß√£o: {e}")
        finally:
            if self.driver:
                input("\n‚è∏Ô∏è Pressione ENTER para fechar o navegador...")
                self.driver.quit()
    
    def show_summary(self):
        """Mostra o resumo final da execu√ß√£o"""
        print("\n" + "="*50)
        print("üìä RESUMO DA AUTOMA√á√ÉO")
        print("="*50)
        
        print(f"\n‚úÖ Chassis processados com sucesso: {len(self.successful_chassis)}")
        for chassis in self.successful_chassis:
            print(f"   ‚úì {chassis}")
        
        print(f"\n‚ùå Chassis com falhas: {len(self.failed_chassis)}")
        for chassis in self.failed_chassis:
            print(f"   ‚úó {chassis}")
        
        total = len(self.successful_chassis) + len(self.failed_chassis)
        success_rate = (len(self.successful_chassis) / total * 100) if total > 0 else 0
        
        print(f"\nüìà Taxa de sucesso: {success_rate:.1f}%")
        print("="*50)

def main():
    """Fun√ß√£o principal - necess√°ria para compatibilidade com o execut√°vel"""
    print("=== ü§ñ AUTOMA√á√ÉO DE DESINSTALA√á√ÉO DE CHASSIS ===\n")
    
    # Verifica se o pandas est√° instalado
    try:
        import pandas as pd
    except ImportError:
        print("‚ùå ERRO: pandas n√£o est√° instalado!")
        print("üí° Execute: pip install pandas openpyxl")
        return
    
    # Verifica se o selenium est√° instalado
    try:
        from selenium import webdriver
    except ImportError:
        print("‚ùå ERRO: selenium n√£o est√° instalado!")
        print("üí° Execute: pip install selenium")
        return
    
    automation = ChassisAutomation()
    automation.run_automation()

if __name__ == "__main__":
    main()